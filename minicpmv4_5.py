# -*- coding: utf-8 -*-
"""MiniCPMv4.5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a9uKU-2Sz_vPfCNfxTwl33LMiaiN1RhD
"""


import torch
import re
import requests
from PIL import Image,ImageDraw
from transformers import AutoModel, AutoTokenizer

# Load model and tokenizer
model = AutoModel.from_pretrained('openbmb/MiniCPM-V-4_5', trust_remote_code=True, attn_implementation='sdpa', dtype=torch.bfloat16)
model = model.eval()

tokenizer = AutoTokenizer.from_pretrained('openbmb/MiniCPM-V-4_5', trust_remote_code=True)

# Function for UI and create map
def survey_ui_and_create_map(image, model, tokenizer):
    """
    Surveys the image and creates a map of UI elements.
    Includes a cleaning step to handle inconsistent model output.
    """
    survey_prompt = """Your task is to meticulously identify every interactive and informational UI element then list all the elements from the provided image using the format below.
You must *only* respond with a list of descriptions and bounding boxes in the specified format. Do not add any introductions, summaries, explanations, or numbered lists.
Here are several examples demonstrating the required format and the desired level of detail:
Description: A search bar with placeholder text "Enter username..." Bbox: <box>10 20 150 50</box>
Description: A toggle switch for "Enable Notifications" Bbox: <box>10 60 80 90</box>
Description: A dropdown menu to select a language Bbox: <box>10 100 150 130</box>
Description: A radio button labeled "Subscribe to newsletter" Bbox: <box>10 140 180 160</box>
Description: A 'Save Changes' button Bbox: <box>10 170 120 200</box>
Description: A 'Cancel' link Bbox: <box>130 175 180 195</box>
Now, for the provided image, list all elements using only this format."""

    msgs = [{'role': 'user', 'content': [image, survey_prompt]}]
    full_response = model.chat(image=image, msgs=msgs, tokenizer=tokenizer,sampling=False)
    print(full_response)
    element_map = []

    clean_response = full_response.replace("<box>", "").replace("</box>", "")

    pattern = re.compile(r"Description: (.*?) Bbox:\s*(.*?)$", re.MULTILINE)
    matches = pattern.findall(clean_response)
    
    print('-'*30)
    print(matches)
    for match in matches:
        description = match[0].strip()
        coords_str = match[1].strip()
        try:
            coords = [int(c.strip()) for c in coords_str.split()]
            element_map.append({"description": description, "bbox": coords})
        except:
            continue

    return element_map

# Find element in the map
def find_element_in_map(user_query, element_map):
    """
    Searches the map using a robust method that normalizes text
    by removing spaces and punctuation before matching.
    """
    # Split the user's query into words
    query_words = user_query.lower().split()

    for element in element_map:
        description_text = element["description"].lower()

        # Normalize "a blue button labeled "log in"" -> "abluebuttonlabeledlogin"
        normalized_description = re.sub(r'[^a-z0-9]', '', description_text)

        try:
            if all(word in normalized_description for word in query_words):
                return element["bbox"]
        except Exception:
            continue

    return None

# --- MAIN PROGRAM ---
try:

    image_url = 'https://i.postimg.cc/6qmN0nkN/Screenshot-2025-08-16-144834.png'       # Screenshot from facebook login-site
    image = Image.open(requests.get(image_url, stream=True).raw).convert("RGB")

    print("üïµÔ∏è  Surveying the UI, please wait...")
    ui_map = survey_ui_and_create_map(image, model, tokenizer)
    print(f"Survey complete! Found {len(ui_map)} elements.")
    print("Type 'quit' or 'exit' to close the program.")
    print("-" * 20)

    while True:
        user_input = input("Enter the UI element you want to find: ")
        if user_input.lower() in ['quit', 'exit']:
            print("Exiting program...")
            break

        bounding_box = find_element_in_map(user_input, ui_map)

        if bounding_box:
            x1, y1, x2, y2 = bounding_box
            click_x = (x1 + x2) / 2
            click_y = (y1 + y2) / 2
            print(f"Element '{user_input}': Click position coordinates: ({click_x}, {click_y})\n")
            
            single_bbox_image = image.copy()
            draw_single = ImageDraw.Draw(single_bbox_image)
        else:
            print(f"Could not find '{user_input}' in the surveyed elements.")

except NameError:
    print("Error: The 'model' or 'tokenizer' variable is not defined. Please ensure the model is loaded first.")
except Exception as e:
    print(f"An error occurred: {e}")